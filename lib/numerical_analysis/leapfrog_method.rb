require 'numerical_analysis/numerical_ode_solving_method'

module NumericalAnalysis

  # Encapsulates the leapfrog method for numerical first order ODE solution. 
  # An initial conditions vector is passed in along with a mathematical 
  # object (either a matrix or a lambda representing a mathematical function 
  # of the dependent and independent variables y and x) representing the 
  # differential function f(y,x) where dy/dx = f(y,x). The next value in the 
  # iteration is generated by calling the iterate method.
  class LeapfrogMethod < NumericalODESolvingMethod
  
    # Adds to the initialize method from the parent class, 
    # NumericalODESolvingMethod, by creating the required instance variables
    # used by the leapfrog method.
    def initialize(
      initial_condition, 
      differential_function, 
      interval,
      initial_independent_variable_value = 0.0
    )
      super
      @first_iteration = true
      @previous_dependent_variable_value = 0
    end
  
    # Iterates to the next value in the solution using the leapfrog method, 
    # e.g.:
    # 
    #   y_next = y_previous + 2 * interval * f(x_current, y_current)
    # 
    #   where f(x,y) is the function in the equation dy/dx = f(x,y),
    #         y is the dependent variable,
    #         x is the independent variable
    # 
    # For the first iteration, the Euler method is used so that an initial
    # value for the previous dependent variable value can be calculated:
    # 
    #   y_next = y_current + interval * f(x_current, y_current)
    # 
    # Returns the resulting dependent variable value and the new independent 
    # variable value in the way defined in the NumericalODESolvingMethod.
    # 
    # Note: an instance of the EulerMethod class could be used here rather 
    # than repeating the method but instead it was chosen that it would be 
    # better to encapsulate the leapfrog method altogether in this one class 
    # such that it is independent of the EulerMethod class.
    def iterate
      # If this is the first iteration, use the Euler method, otherwise use
      # the leapfrog method.
      if @first_iteration
        # Apply the Euler method to the current variable values to obtain 
        # the next value.
        next_value = @current_dependent_variable_value + 
          @differential_function.call(
            @current_independent_variable_value,
            @current_dependent_variable_value
          ) * @interval
      
        # Set the first_iteration instance variable to false so that from 
        # now on the leapfrog method is used.
        @first_iteration = false
      else
        # Apply the leapfrog method to the current and previous vectors to
        # obtain the new vector.
        next_value = @previous_dependent_variable_value + 
          @differential_function.call(
            @current_independent_variable_value,
            @current_dependent_variable_value
          ) * 2 * @interval
      end
    
    
      # Set the current and previous dependent and independent variables to 
      # their new values.
      @current_independent_variable_value += interval
      @previous_dependent_variable_value = @current_dependent_variable_value
      @current_dependent_variable_value = next_value

      # Call super to return the new values.
      super
    end
  
    # Adds to the reset method from the parent class, 
    # NumericalODESolvingMethod, by resetting the leapfrog method such that 
    # the Euler method is used again for the first iteration.
    def reset
      super
      @first_iteration = true
    end
  
  end

end
